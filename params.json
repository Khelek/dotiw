{"name":"Dotiw","tagline":"Better distance of time in words for Rails","body":"# dotiw\r\n\r\ndotiw is a plugin for Rails that overrides the default `distance_of_time_in_words` and provides a more accurate output. Do you crave accuracy down to the second? So do I. That's why I made this plugin. Take this for a totally kickass example:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.year + 2.months + 3.days + 4.hours + 5.minutes + 6.seconds, true)\r\n    => \"1 year, 2 months, 3 days, 4 hours, 5 minutes, and 6 seconds\"\r\n     \r\nAlso if one of the measurement is zero it will not output it:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.year + 2.months + 4.hours + 5.minutes + 6.seconds, true)\r\n    => \"1 year, 2 months, 4 hours, 5 minutes, and 6 seconds\"\r\n     \r\nBetter than \"about 1 year\", am I right? Of course I am.\r\n\r\n\"But Ryan!\", you say, \"What happens if the time is only in seconds but because of the default the seconds aren't shown? Won't it be blank?\"\r\n\"No!\" I triumphantly reply:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.second, false)\r\n    => \"1 second\"\r\n\r\nThe third argument for this method is whether or not to include seconds. By default this is `false` (because in Rails' `distance_of_time_in_words` it is), you can turn it on though by passing `true` as the third argument:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.year + 1.second, true)\r\n    => \"1 year, and 1 second\" \r\n\r\nYes this could just be merged into the options hash but I'm leaving it here to ensure \"backwards-compatibility\",\r\nbecause that's just an insanely radical thing to do. \\m/\r\n\r\nThe last argument is an optional options hash that can be used to manipulate behavior and (which uses `to_sentence`).\r\n\r\nDon't like having to pass in `Time.now` all the time? Then use `time_ago_in_words` which also will *rock your\r\nworld*:\r\n\r\n    >> time_ago_in_words(Time.now + 3 days + 1.second)\r\n    => \"3 days, and 1 second\"\r\n\r\nOh, and did I mention it supports I18n? Oh yeah. Rock on!\r\n\r\n### Options\r\n\r\n#### :locale\r\n\r\nYou can pass in a locale and it'll output it in whatever language you want (provided you have translations, otherwise it'll default to English):\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.minute, false, :locale => \"es\")\r\n    => \"1 minuto\"\r\n    \r\nThis will also be passed to `to_sentence`\r\n\r\n#### :vague\r\n\r\nSpecify this if you want it to use the old `distance_of_time_in_words`. The value can be anything except `nil` or `false`.\r\n\r\n#### :accumulate_on\r\n\r\nSpecifies the maximum output unit which will accumulate all the surplus. Say you set it to seconds and your time difference is of 2 minutes then the output would be 120 seconds. Here's a code example:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 2.hour + 70.second, true, :accumulate_on => :minutes)\r\n    => \"121 minutes and 10 seconds\"\r\n\r\n#### :only\r\n\r\n**Note that values passed into this option must be passed in as strings!**\r\n\r\nOnly want a specific measurement of time? No problem!\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute, false, :only => \"minutes\")\r\n    => \"1 minute\"\r\n\r\nYou only want some? No problem too!\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.day + 1.minute, false, :only => [\"minutes\", \"hours\"])\r\n    => \"1 hour and 1 minute\"\r\n\r\n#### :except\r\n\r\n**Note that values passed into this option must be passed in as strings!**\r\n\r\nDon't want a measurement of time? No problem!\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute, false, :except => \"minutes\")\r\n    => \"1 hour\"\r\n\r\nCulling a whole group of measurements of time:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.day + 1.minute, false, :except => [\"minutes\", \"hours\"])\r\n    => \"1 day\"\r\n    \r\n#### :highest\\_measure\\_only\r\n\r\nFor times when Rails `distance_of_time_in_words` is not precise enough and `DOTIW` is too precise. For instance, if you only want to know the highest time part (measure) that elapsed between two dates.\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute + 1.second, true, { :highest_measure_only => true })\r\n    => \"1 hour\"\r\n\r\nNotice how minutes and seconds were removed from the output. Another example:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.minute + 1.second, true, { :highest_measure_only => true })\r\n    => \"1 minute\"\r\n\r\nMinutes are the highest measure, so seconds were discarded from the output.\r\n\r\n#### :highest\\_measuress\r\n\r\nWhen you want variable precision from `DOTIW`:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute + 1.second, true, { :highest_measures => 2 })\r\n    => \"1 hour and 1 minute\"\r\n\r\n#### :words_connector\r\n\r\n**This is an option for `to_sentence`, defaults to ', '**\r\n\r\nUsing something other than a comma:\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute + 1.second, true, { :words_connector => ' - ' })\r\n    => \"1 hour - 1 minute, and 1 second\"\r\n    \r\n#### :two\\_words\\_connector\r\n\r\n**This is an option for `to_sentence`, defaults to ' and '**\r\n\r\nUsing something other than 'and':\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute, true, { :two_words_connector => ' plus ' })\r\n    => \"1 hour plus 1 minute\"\r\n\r\n#### :last\\_word\\_connector \r\n\r\n**This is an option for `to_sentence`, defaults to ', and '**\r\n\r\nUsing something other than ', and':\r\n\r\n    >> distance_of_time_in_words(Time.now, Time.now + 1.hour + 1.minute + 1.second, true, { :last_word_connector => ', finally ' })\r\n    => \"1 hour, 1 minute, finally 1 second\"\r\n\r\n## distance\\_of\\_time\r\n\r\nIf you have simply a number of seconds you can get the \"stringified\" version of this by using `distance_of_time`:\r\n\r\n    >> distance_of_time(300)\r\n    => \"5 minutes\"\r\n\r\n## distance\\_of\\_time\\_in\\_words\\_hash\r\n\r\nDon't like any format you're given? That's cool too! Here, have an indifferent hash version:\r\n\r\n    >> distance_of_time_in_words_hash(Time.now, Time.now + 1.year + 2.months + 3.days + 4.hours + 5.minutes + 6.seconds)\r\n    => {:days => 3, :seconds => 6, :minutes => 5, :years => 1, :hours => 4, :months => 2}\r\n\r\nIndifferent means that you can access all keys by their `String` or `Symbol` version.\r\n    \r\n## distance\\_of\\_time\\_in\\_percent\r\n\r\nIf you want to calculate a distance of time in percent, use `distance_of_time_in_percent`. The first argument is the beginning time, the second argument the \"current\" time and the third argument is the end time. This method takes the same options as [`number_with_precision`](http://api.rubyonrails.org/classes/ActionView/Helpers/NumberHelper.html#method-i-number_with_precision).\r\n\r\n    distance_of_time_in_percent(\"04-12-2009\".to_time, \"29-01-2010\".to_time, \"04-12-2010\".to_time, options)\r\n    \r\n\r\n## Contributors\r\n\r\n* [chendo](http://github.com/chendo) - for talking through it with me and drawing on the whiteboard\r\n* [Derander](http://github.com/derander) - correct Spanish translations\r\n* [DBA](http://github.com/dba) - Commits leading up to the 0.7 release. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}